# 객체와 자료구조
변수를 private로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다. 
그렇가면 왜 많은 프로그래머들이 조회(get) 함수와 설정(set)함수를 당연하게 공개해 비공개(private) 변수를 외부에 노출할까?

### 자료 추상화
- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다.
- 구현을 감추려면 추상화가 필요하다
- 인터페이스나 조회/설정 함수만으로 추상화가 이뤄지지는 않는다. 

### 자료/객체 비대칭
- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다
- 자료구조는 자료를 그대로 공개하며 별다른 함수를 제공하지 않는다
- (자료구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.
- 때로는 단순한 자료구조와 절차적인 코드가 적합한 상황도 있다.

### 디미터의 법칙
- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
- 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다
    - 클래스 C
    - f가 생성한 객체
    - f 인수로 넘어온 객체
    - C 인스턴스 변수에 저장된 객체

#### 기차 충돌
```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()
```
- 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다.
```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
- 객체라면 내부 구조를 숨겨야 하므로 디미터의 법칙을 위반한다
- 자료 구조라면 당연히 내부 구조를 노출하므로 디미터의 법칙에 위반하지 않는다.

#### 잡종 구조
- 때때로 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다. 
- 이런 잡종 구조는 새로운 함수는 물론이고 새로운 자료구조를 추가하는 것도 어렵다.

#### 구조체 감추기
- 객체라면 내부 구조를 감춰야 한다.
- ctxt가 객체라면 원가를 하라고 말해야지 속을 드러내라고 하면 안된다.
- get을 해야하는 이유를 생각해보고 그 일을 객체에게 맡긴다.
- 그럼 객체는 내부 구조를 드러내지도 않으며, 모듈에서 해당 함수는 자신이 몰라야하는 여러 객체를 탐색할 필요가 없다.

#### 자료 전달 객체
- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스이다. 이런 자료 구조체를 때로는 자료 전달 객체(DTO)라고 한다.

#### 활성 레코드
- DTO의 특수한 형태이다. 
- 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과이다.
- 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객테는 따로 생성한다.

### 결론
- 객체는 동작을 공개하고 자료를 숨긴다.
- 그래서 기존을 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.
- 자료 구조는 별다른 동작 없이 자룔ㄹ 노출한다.
- 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나 기존 함수에 새 자료 구조를 추가하기는 어렵다.
- 새로운 자료 타입을 추가하는 유연성이 필요하다면 객체가, 다른 경우로 새로운 동작을 추가하는 유연성이 필요하다면 자료 구조와 절차적인 코드가 더 적합하다.